#ifndef MATRIX_BASE_H
#define MATRIX_BASE_H

#include <vector>
#include <functional>
#include <sstream>

class DenseMatrix;
class SparseMatrix;

/**
* Base class for matrix implementations. Every matrix implementation should use this base class because BIE-PA2 demands it.
*/
class MatrixBase
{
public:
	/**
	* Threshold value for Density. Threshold values themselves are always considered Dense.
	*/
	const double DensityThreshold = 0.5;
	/**
	* Threshold value for Sparsity. Threshold values themselves are always considered Dense (yes, Dense, even for this one).
	*/
	const double SparsityThreshold = 1 - DensityThreshold;
	/**
	* Default Constructor generated by the compiler.
	*/
	MatrixBase() = default;
	/**
	* Copy Constructor generated by the compiler.
	*/
	MatrixBase(const MatrixBase& other) = default;
	/**
	* Move Constructor generated by the compiler.
	*/
	MatrixBase(MatrixBase&& other) noexcept = default;
	/**
	* Copy Assignment Operator generated by the compiler.
	*/
	MatrixBase& operator=(const MatrixBase& other) = default;
	/**
	* Move Assignment Operator generated by the compiler.
	*/
	MatrixBase& operator=(MatrixBase&& other) noexcept = default;
	/**
	* Destructor generated by the compiler.
	*/
	virtual ~MatrixBase() = default;
	/**
	* Returns the number of rows of this matrix.
	*/
	virtual size_t getNumRows() const = 0;
	/**
	* Returns the number of columns of this matrix.
	*/
	virtual size_t getNumColumns() const = 0;
	/**
	* Returns the double value at a given cell. Indices start from zero.
	* @param row Row index of the matrix.
	* @param column Column index of the matrix.
	* @return The double value which resides in the cell.
	*/
	virtual double getCell(size_t row, size_t column) const = 0;
	/**
	* Sets a cell to the given value. Indices start from zero.
	* @param row Row index of the matrix.
	* @param column Column index of the matrix.
	* @param value The value to be set in the cell.
	*/
	virtual void setCell(size_t row, size_t column, double value) = 0;
	/**
	* Resizes the number of rows of the matrix.
	* @param newNumRows If the argument is less than current num rows, the 'extra part' is truncated. If the argument is greater, then the new cells are initialized to zero.
	*/
	virtual void resizeNumRows(size_t newNumRows) = 0;
	/**
	* Resizes the number of columns of the matrix.
	* @param newNumColumns If the argument is less than current num columns, the 'extra part' is truncated. If the argument is greater, then the new cells are initialized to zero.
	*/
	virtual void resizeNumColumns(size_t newNumColumns) = 0;
	/**
	* Resizes the number of rows and columns of the matrix in a single function.
	* @param newNumRows If the argument is less than current num rows, the 'extra part' is truncated. If the argument is greater, then the new cells are initialized to zero.
	* @param newNumColumns If the argument is less than current num columns, the 'extra part' is truncated. If the argument is greater, then the new cells are initialized to zero.
	*/
	virtual void resize(size_t newNumRows, size_t newNumColumns) = 0;
	/**
	* Transposes the matrix. Yes.
	*/
	virtual void transpose() = 0;
	/**
	* Gets the Sparsity value of the matrix. Sparsity is the ratio of numZeroElements/numTotalElements.
	* @see MatrixBase::SparsityThreshold
	* @return Sparsity floating point value between 0 and 1. The SparsityThreshold value itself is NOT considered Sparse. It is reserved for Density.
	*/
	virtual double getSparsity() const = 0;
	/**
	* Gets the Density value of the matrix. Density is the ratio of numNonZeroElements/numTotalElements.
	* @see MatrixBase::DensityThreshold
	* @return Density floating point value between 0 and 1. The DensityThreshold value itself IS considered Density.
	*/
	virtual double getDensity() const = 0;
	/**
	* Checks if the matrix's Sparsity is greater than SparsityThreshold.
	* @see MatrixBase::SparsityThreshold
	* @see getSparsity()
	* @return True if Sparse, false if Dense.
	*/
	virtual bool isSparse() const = 0;
	/**
	* Checks if the matrix's Density is greater than or equal to DensityThreshold.
	* @see MatrixBase::DensityThreshold
	* @see getDensity()
	* @return True if Dense, false if Sparse.
	*/
	virtual bool isDense() const = 0;
	/**
	* Checks whether or not the MatrixBase instance requires conversion to another MatrixBase instance.
	* @see MatrixBase::DensityThreshold
	* @see getDensity()
	* @see isDense()
	* @return True if it requires conversion, false if not.
	*/
	virtual bool requiresConversion() const = 0;
	/**
	* Returns the approxiate MatrixBase instance if it requires any conversion.
	* @see requiresConversion()
	* @return A raw pointer to a MatrixBase instance.
	*/
	virtual MatrixBase* getConvertedCopy() const = 0;
	/**
	* Clones (deep copy) this MatrixBase instance.
	* @return A raw pointer to a MatrixBase instance.
	*/
	virtual MatrixBase* clone() const = 0;
	/**
	* Creates a DenseMatrix version of this matrix, regardless of the Density value. Doesn't make sense to use this method if the matrix is sparse.
	* @see isDense()
	* @return A raw pointer to DenseMatrix instance.
	*/
	virtual DenseMatrix* cloneAsDenseMatrix() const = 0;
	/**
	* Creates a SparseMatrix version of this matrix, regardless of the Sparisty value. Doesn't make sense to use this method if the matrix is Dense.
	* @see isDense()
	* @return A raw pointer to DenseMatrix instance.
	*/
	virtual SparseMatrix* cloneAsSparseMatrix() const = 0;
	/**
	* Creates a vector of 3-tuples. The first two size_t are the row & column data; the double is the value at the row & column coordinate. It makes it easier to use SparseMatrix. Acts as a short hack instead of writing a custom iterator.
	* @return A vector of 3-tuples, which contains row & column coordinates; and their corresponding double value.
	*/
	virtual std::vector<std::tuple<size_t, size_t, double>> getCellDataList() const = 0;
	/**
	* Scales every cell of this matrix by the given scalar value.
	* @param scalar Scalar value to scale each cell.
	*/
	virtual void scale(double scalar) = 0;
	/**
	* Checks if this matrix is equal to the argument matrix. Method implements Double Dispatch. This particular method just calls the equal method on the argument to activate polymorphism.
	* @param right The other MatrixBase.
	* @return True if equal, false if not equal.
	*/
	virtual bool equal(const MatrixBase& right) const = 0;
	/**
	* Checks if this matrix is equal to the argument matrix. Method implements Double Dispatch. This particular checks if this MatrixBase is equal to the other DenseMatrix.
	* @param right The other DenseMatrix. This is meant to be called by the more generic equal method.
	* @return True if equal, false if not equal.
	*/
	virtual bool equal(const DenseMatrix& right) const = 0;
	/**
	* Checks if this matrix is equal to the argument matrix. Method implements Double Dispatch. This particular checks if this MatrixBase is equal to the other SparseMatrix.
	* @param right The other SparseMatrix. This is meant to be called by the more generic equal method.
	* @return True if equal, false if not equal.
	*/
	virtual bool equal(const SparseMatrix& right) const = 0;
	/**
	* Performs matrix addition with the argument and returns the result. Method implements Double Dispatch. This particular method just calls the add method on the argument to activate polymorphism.
	* @param right The other MatrixBase.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* add(const MatrixBase& right) const = 0;
	/**
	* Performs matrix addition with the argument and returns the result. Method implements Double Dispatch. This particular method adds this MatrixBase to the other DenseMatrix and returns the result.
	* @param right The other DenseMatrix. This is meant to be called by the more generic add method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* add(const DenseMatrix& right) const = 0;
	/**
	* Performs matrix addition with the argument and returns the result. Method implements Double Dispatch. This particular method adds this MatrixBase to the other SparseMatrix and returns the result.
	* @param right The other SparseMatrix. This is meant to be called by the more generic add method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* add(const SparseMatrix& right) const = 0;
	/**
	* Performs matrix subtraction with the argument and returns the result. Method implements Double Dispatch. This particular method just calls the subtract method on the argument to activate polymorphism.
	* @param right The other MatrixBase.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* subtract(const MatrixBase& right) const = 0;
	/**
	* Performs matrix subtraction with the argument and returns the result. Method implements Double Dispatch. This particular method subtracts this MatrixBase from the argument DenseMatrix.
	* @param right The other DenseMatrix. This is meant to be called by the more generic subtract method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* subtract(const DenseMatrix& right) const = 0;
	/**
	* Performs matrix subtraction with the argument and returns the result. Method implements Double Dispatch. This particular method subtracts this MatrixBase from the argument SparseMatrix.
	* @param right The other SparseMatrix. This is meant to be called by the more generic subtract method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* subtract(const SparseMatrix& right) const = 0;
	/**
	* Performs matrix multiplication with the argument and returns the result. Method implements Double Dispatch. This particular method just calls the multiply method on the argument to activate polymorphism.
	* @param right The other MatrixBase.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* multiply(const MatrixBase& right) const = 0;
	/**
	* Performs matrix multiplication with the argument and returns the result. Method implements Double Dispatch. This particular method multiples the argument DenseMatrix by this MatrixBase.
	* @param right The other DenseMatrix. This is meant to be called by the more generic multiply method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* multiply(const DenseMatrix& right) const = 0;
	/**
	* Performs matrix multiplication with the argument and returns the result. Method implements Double Dispatch. This particular method multiples the argument SparseMatrix by this SparseMatrix.
	* @param right The other SparseMatrix. This is meant to be called by the more generic multiply method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* multiply(const SparseMatrix& right) const = 0;
	/**
	* Merges this and the argument matrix by columns and returns the result. Method implements Double Disptch. This particular method just calls the mergeByColumns method on the argument to activate polymorphism.
	* @param right The other MatrixBase.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* mergeByColumns(const MatrixBase& right) const = 0;
	/**
	* Merges this and the argument matrix by columns and returns the result. Method implements Double Disptch. This particular method merges the argument matrix with this and returns the result.
	* @param right The other DenseMatrix. This is meant to be called by the more generic mergeByColumns method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* mergeByColumns(const DenseMatrix& right) const = 0;
	/**
	* Merges this and the argument matrix by columns and returns the result. Method implements Double Disptch. This particular method merges the argument matrix with this and returns the result.
	* @param right The other SparseMatrix. This is meant to be called by the more generic mergeByColumns method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* mergeByColumns(const SparseMatrix& right) const = 0;
	/**
	* Merges this and the argument matrix by rows and returns the result. Method implements Double Disptch. This particular method just calls the mergeByRows method on the argument to activate polymorphism.
	* @param right The other MatrixBase.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* mergeByRows(const MatrixBase& right) const = 0;
	/**
	* Merges this and the argument matrix by rows and returns the result. Method implements Double Disptch. This particular method merges the argument matrix with this and returns the result.
	* @param right The other DenseMatrix. This is meant to be called by the more generic mergeByRows method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* mergeByRows(const DenseMatrix& right) const = 0;
	/**
	* Merges this and the argument matrix by rows and returns the result. Method implements Double Disptch. This particular method merges the argument matrix with this and returns the result.
	* @param right The other SparseMatrix. This is meant to be called by the more generic mergeByRows method.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* mergeByRows(const SparseMatrix& right) const = 0;
	/**
	* Splits this matrix by columns. The user will always specify the number of columns of the left matrix.
	* @param leftNewNumColumns The new number of columns for the left side of the split matrix. Must be greater than 0 and less than this matrix's numColumns.
	* @param returnLeftMatrix If you want the left part of the matrix to be returned, set to true. If you want the right side, then set to false.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* splitByColumn(size_t leftNewNumColumns, bool returnLeftMatrix) const = 0;
	/**
	* Splits this matrix by rows. The user will always specify the number of rows of the top matrix.
	* @param topNewNumRows The new number of rows for the top side of the split matrix. Must be greater than 0 and less than this matrix's numRows.
	* @param returnTopMatrix If you want the top part of the matrix to be returned, set to true. If you want the bottom side, then set to false.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* splitByRow(size_t topNewNumRows, bool returnTopMatrix) const = 0;
	/**
	* Returns the submatrix of this matrix. The submatrix will be specified as a "square" area within the bigger matrix. The parameters are the start INDEX and the SIZE of the dimensions.
	* @param subRowBeginIndex The beginning INDEX of the row of the submatrix.
	* @param subNumRows The number of rows of the submatrix. This is not an index, it's a SIZE.
	* @param subColumnBeginIndex The beginning INDEX of the row of the submatrix.
	* @param subNumColumns The number of columns of the submatrix. This is not an index, it's a SIZE.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* getSubMatrix(size_t subRowBeginIndex, size_t subNumRows, size_t subColumnBeginIndex, size_t subNumColumns) const = 0;
	/**
	* Returns a submatrix by ignoring the current matrix's row and column as specified by the arguments.
	* @param ignoredRowIndex The row index to be ignored in the bigger matrix.
	* @param ignoredColumnIndex The column index to be ignored in the bigger matrix.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* getSubMatrix(size_t ignoredRowIndex, size_t ignoredColumnIndex) const = 0;
	/**
	* Returns the top left part of this matrix, as specified by the row & column coordinates of the method's arguments.
	* @param ignoredRowIndex The row index to be ignored.
	* @param ignoredColumnIndex The column index to be ignored.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* getSubMatrixTopLeft(size_t ignoredRowIndex, size_t ignoredColumnIndex) const = 0;
	/**
	* Returns the top right part of this matrix, as specified by the row & column coordinates of the method's arguments.
	* @param ignoredRowIndex The row index to be ignored.
	* @param ignoredColumnIndex The column index to be ignored.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* getSubMatrixTopRight(size_t ignoredRowIndex, size_t ignoredColumnIndex) const = 0;
	/**
	* Returns the bottom left part of this matrix, as specified by the row & column coordinates of the method's arguments.
	* @param ignoredRowIndex The row index to be ignored.
	* @param ignoredColumnIndex The column index to be ignored.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* getSubMatrixBottomLeft(size_t ignoredRowIndex, size_t ignoredColumnIndex) const = 0;
	/**
	* Returns the bottom right part of this matrix, as specified by the row & column coordinates of the method's arguments.
	* @param ignoredRowIndex The row index to be ignored.
	* @param ignoredColumnIndex The column index to be ignored.
	* @return A raw pointer to MatrixBase instance.
	*/
	virtual MatrixBase* getSubMatrixBottomRight(size_t ignoredRowIndex, size_t ignoredColumnIndex) const = 0;
	/**
	* Calculates the determinant of the matrix using Laplace Expansion. The matrix is assumed to be square.
	* @return A double floating point value containing the determinant of this matrix.
	*/
	virtual double getDeterminant() const = 0;
	/**
	* Returns the matrix of minors of this matrix. Used while calculating the inverse of a matrix. Doesn't make sense to use it alone. The matrix is assumed to be square.
	* @return A raw pointer to MatrixBase instance, containing the matrix of minors.
	*/
	virtual MatrixBase* getMinorMatrix() const = 0;
	/**
	* Applies the so called checkerboard pattern on this matrix. It's used to calculate the Cofactor Matrix from Minor Matrix while calculating the inverse of a matrix. Doesn't make sense to use it alone. The matrix is assumed to be square.
	*/
	virtual void applyCheckerboardPattern() = 0;
	/**
	* Returns the inverse of this matrix. If the inverse doesn't exist, it will return nullptr. The matrix is assumed to be square.
	* @param determinant The determinant of this matrix. getInverse method will return nullptr if the argument determinant is equal to zero.
	* @see getDeterminant()
	* @return A raw pointer to MatrixBase instance, containing the inverse of this matrix.
	*/
	virtual MatrixBase* getInverse(double determinant) const = 0;
	/**
	* Prepares a neat looking output string for this matrix. The cells are nicely aligned with respect to their columns. The output floating point values are fixed (std::fixed).
	* @param precision The number of digits after the floating point.
	* @return The output string which contains the neatly aligned cell values.
	*/
	virtual std::string getPrintStr(size_t precision) const = 0;
	/**
	* Treats this and the argument matrices as a Systems of Linear Equations, and performs Gaussian Eliminations to find the solution set, and return it as a string. The augmentedColumn matrix must have 1 column.
	* @param augmentedColumn A column matrix with 1 column. It contains the numbers which the equations are equal to.
	* @param verbose True if the output string should contain the steps of Gaussian Elimination, false if not.
	* @param doublePrecision The number of digits after the floating point when outputting the cells of the matrix.
	* @see getPrintStr()
	* @return A string which contains the solution set (with steps if verbose was true) of the Systems of Linear Equations.
	*/
	virtual std::string solveFor(const MatrixBase& augmentedColumn, bool verbose, size_t doublePrecision) const = 0;
	/**
	* Performs Gaussian Elimination and finds the rank from the Reduced Echelon Form of this matrix. Uses a DenseMatrix copy to perform the operation.
	* @see DenseMatrix::getRank()
	* @return The rank of this matrix.
	*/
	virtual size_t getRank() const = 0;
private:
};

#endif // MATRIX_BASE_H
